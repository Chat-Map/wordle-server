// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: game.sql

package pgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const fetchGame = `-- name: FetchGame :one
SELECT id, creator, correct_word, created_at, started_at, ended_at from game WHERE id = $1
`

func (q *Queries) FetchGame(ctx context.Context, id pgtype.UUID) (Game, error) {
	row := q.db.QueryRow(ctx, fetchGame, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Creator,
		&i.CorrectWord,
		&i.CreatedAt,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const finishGame = `-- name: FinishGame :exec
UPDATE game SET ended_at = coalesce($2, NOW()) WHERE id = $1
`

type FinishGameParams struct {
	ID      pgtype.UUID
	EndedAt pgtype.Timestamptz
}

func (q *Queries) FinishGame(ctx context.Context, arg FinishGameParams) error {
	_, err := q.db.Exec(ctx, finishGame, arg.ID, arg.EndedAt)
	return err
}

const gamePlayers = `-- name: GamePlayers :many
SELECT p.id, p.username, gp.correct_guesses, gp.correct_guesses_time, gp.finished 
FROM game_player gp 
JOIN player p ON gp.player_id = p.id 
WHERE gp.game_id = $1
`

type GamePlayersRow struct {
	ID                 int32
	Username           string
	CorrectGuesses     pgtype.Int4
	CorrectGuessesTime pgtype.Timestamptz
	Finished           pgtype.Timestamptz
}

// returns all the players that played this game
func (q *Queries) GamePlayers(ctx context.Context, gameID pgtype.UUID) ([]GamePlayersRow, error) {
	rows, err := q.db.Query(ctx, gamePlayers, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GamePlayersRow
	for rows.Next() {
		var i GamePlayersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.CorrectGuesses,
			&i.CorrectGuessesTime,
			&i.Finished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playerGames = `-- name: PlayerGames :many
SELECT g.id, g.correct_word, g.created_at, g.started_at, g.ended_at, 
  p.id AS creator_id, p.username AS creator_username,
  gp.player_id, gp.played_words, gp.correct_guesses, gp.correct_guesses_time, gp.finished
FROM game g
JOIN game_player gp ON g.id = gp.game_id
JOIN player p ON g.creator = p.id
WHERE gp.player_id = $1
ORDER BY gp.finished DESC
LIMIT $3 OFFSET $2
`

type PlayerGamesParams struct {
	PlayerID int32
	Offset   int32
	Limit    pgtype.Int4
}

type PlayerGamesRow struct {
	ID                 pgtype.UUID
	CorrectWord        string
	CreatedAt          pgtype.Timestamptz
	StartedAt          pgtype.Timestamptz
	EndedAt            pgtype.Timestamptz
	CreatorID          int32
	CreatorUsername    string
	PlayerID           int32
	PlayedWords        []byte
	CorrectGuesses     pgtype.Int4
	CorrectGuessesTime pgtype.Timestamptz
	Finished           pgtype.Timestamptz
}

func (q *Queries) PlayerGames(ctx context.Context, arg PlayerGamesParams) ([]PlayerGamesRow, error) {
	rows, err := q.db.Query(ctx, playerGames, arg.PlayerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerGamesRow
	for rows.Next() {
		var i PlayerGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.CorrectWord,
			&i.CreatedAt,
			&i.StartedAt,
			&i.EndedAt,
			&i.CreatorID,
			&i.CreatorUsername,
			&i.PlayerID,
			&i.PlayedWords,
			&i.CorrectGuesses,
			&i.CorrectGuessesTime,
			&i.Finished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startGame = `-- name: StartGame :exec
UPDATE game SET started_at = coalesce($2, NOW()) WHERE id = $1
`

type StartGameParams struct {
	ID        pgtype.UUID
	StartedAt pgtype.Timestamptz
}

func (q *Queries) StartGame(ctx context.Context, arg StartGameParams) error {
	_, err := q.db.Exec(ctx, startGame, arg.ID, arg.StartedAt)
	return err
}

const updatePlayerStats = `-- name: UpdatePlayerStats :exec
INSERT INTO game_player (game_id, player_id) VALUES ($1, $2)
ON CONFLICT (game_id, player_id) 
DO UPDATE SET played_words=$3, correct_guesses=$4, correct_guesses_time=$5, finished=$6
`

type UpdatePlayerStatsParams struct {
	GameID             pgtype.UUID
	PlayerID           int32
	PlayedWords        []byte
	CorrectGuesses     pgtype.Int4
	CorrectGuessesTime pgtype.Timestamptz
	Finished           pgtype.Timestamptz
}

// This upserts the player stats if they were not already present
func (q *Queries) UpdatePlayerStats(ctx context.Context, arg UpdatePlayerStatsParams) error {
	_, err := q.db.Exec(ctx, updatePlayerStats,
		arg.GameID,
		arg.PlayerID,
		arg.PlayedWords,
		arg.CorrectGuesses,
		arg.CorrectGuessesTime,
		arg.Finished,
	)
	return err
}
